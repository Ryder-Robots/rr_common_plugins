// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rr_serial.proto

#include "rr_serial.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace org {
namespace ryderrobots {
namespace ros2 {
namespace serial {
PROTOBUF_CONSTEXPR Monitor::Monitor(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.is_request_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MonitorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MonitorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MonitorDefaultTypeInternal() {}
  union {
    Monitor _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MonitorDefaultTypeInternal _Monitor_default_instance_;
PROTOBUF_CONSTEXPR BadRequest::BadRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.etype_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BadRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BadRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BadRequestDefaultTypeInternal() {}
  union {
    BadRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BadRequestDefaultTypeInternal _BadRequest_default_instance_;
PROTOBUF_CONSTEXPR FeatureList::FeatureList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.has_gps_)*/false
  , /*decltype(_impl_.has_joy_)*/false
  , /*decltype(_impl_.has_batt_state_)*/false
  , /*decltype(_impl_.has_img_)*/false
  , /*decltype(_impl_.has_imu_)*/false
  , /*decltype(_impl_.has_ranges_)*/false
  , /*decltype(_impl_.gps_status_)*/0
  , /*decltype(_impl_.joy_status_)*/0
  , /*decltype(_impl_.batt_state_status_)*/0
  , /*decltype(_impl_.img_status_)*/0
  , /*decltype(_impl_.ranges_status_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FeatureListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FeatureListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FeatureListDefaultTypeInternal() {}
  union {
    FeatureList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FeatureListDefaultTypeInternal _FeatureList_default_instance_;
PROTOBUF_CONSTEXPR Quaternion::Quaternion(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_.w_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct QuaternionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QuaternionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QuaternionDefaultTypeInternal() {}
  union {
    Quaternion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QuaternionDefaultTypeInternal _Quaternion_default_instance_;
PROTOBUF_CONSTEXPR Vector3::Vector3(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Vector3DefaultTypeInternal {
  PROTOBUF_CONSTEXPR Vector3DefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Vector3DefaultTypeInternal() {}
  union {
    Vector3 _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Vector3DefaultTypeInternal _Vector3_default_instance_;
PROTOBUF_CONSTEXPR MspRawImu::MspRawImu(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.orientation_covariance_)*/{}
  , /*decltype(_impl_.angular_velocity_covariance_)*/{}
  , /*decltype(_impl_.linear_acceleration_covariance_)*/{}
  , /*decltype(_impl_.orientation_)*/nullptr
  , /*decltype(_impl_.angular_velocity_)*/nullptr
  , /*decltype(_impl_.linear_acceleration_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MspRawImuDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MspRawImuDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MspRawImuDefaultTypeInternal() {}
  union {
    MspRawImu _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MspRawImuDefaultTypeInternal _MspRawImu_default_instance_;
PROTOBUF_CONSTEXPR MspIdent::MspIdent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.feature_list_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MspIdentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MspIdentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MspIdentDefaultTypeInternal() {}
  union {
    MspIdent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MspIdentDefaultTypeInternal _MspIdent_default_instance_;
PROTOBUF_CONSTEXPR Request::Request(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.op_)*/0
  , /*decltype(_impl_.data_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct RequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestDefaultTypeInternal() {}
  union {
    Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestDefaultTypeInternal _Request_default_instance_;
PROTOBUF_CONSTEXPR Response::Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.op_)*/0
  , /*decltype(_impl_.data_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponseDefaultTypeInternal() {}
  union {
    Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponseDefaultTypeInternal _Response_default_instance_;
}  // namespace serial
}  // namespace ros2
}  // namespace ryderrobots
}  // namespace org
static ::_pb::Metadata file_level_metadata_rr_5fserial_2eproto[9];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_rr_5fserial_2eproto[2];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_rr_5fserial_2eproto = nullptr;

const uint32_t TableStruct_rr_5fserial_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::Monitor, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::Monitor, _impl_.is_request_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::BadRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::BadRequest, _impl_.etype_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::FeatureList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::FeatureList, _impl_.has_gps_),
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::FeatureList, _impl_.has_joy_),
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::FeatureList, _impl_.has_batt_state_),
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::FeatureList, _impl_.has_img_),
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::FeatureList, _impl_.has_imu_),
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::FeatureList, _impl_.has_ranges_),
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::FeatureList, _impl_.gps_status_),
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::FeatureList, _impl_.joy_status_),
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::FeatureList, _impl_.batt_state_status_),
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::FeatureList, _impl_.img_status_),
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::FeatureList, _impl_.ranges_status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::Quaternion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::Quaternion, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::Quaternion, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::Quaternion, _impl_.z_),
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::Quaternion, _impl_.w_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::Vector3, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::Vector3, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::Vector3, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::Vector3, _impl_.z_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::MspRawImu, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::MspRawImu, _impl_.orientation_),
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::MspRawImu, _impl_.orientation_covariance_),
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::MspRawImu, _impl_.angular_velocity_),
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::MspRawImu, _impl_.angular_velocity_covariance_),
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::MspRawImu, _impl_.linear_acceleration_),
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::MspRawImu, _impl_.linear_acceleration_covariance_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::MspIdent, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::MspIdent, _impl_.feature_list_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::Request, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::Request, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::Request, _impl_.op_),
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::Request, _impl_.data_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::Response, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::Response, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::Response, _impl_.op_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::org::ryderrobots::ros2::serial::Response, _impl_.data_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::org::ryderrobots::ros2::serial::Monitor)},
  { 7, -1, -1, sizeof(::org::ryderrobots::ros2::serial::BadRequest)},
  { 14, -1, -1, sizeof(::org::ryderrobots::ros2::serial::FeatureList)},
  { 31, -1, -1, sizeof(::org::ryderrobots::ros2::serial::Quaternion)},
  { 41, -1, -1, sizeof(::org::ryderrobots::ros2::serial::Vector3)},
  { 50, -1, -1, sizeof(::org::ryderrobots::ros2::serial::MspRawImu)},
  { 62, -1, -1, sizeof(::org::ryderrobots::ros2::serial::MspIdent)},
  { 69, -1, -1, sizeof(::org::ryderrobots::ros2::serial::Request)},
  { 78, -1, -1, sizeof(::org::ryderrobots::ros2::serial::Response)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::org::ryderrobots::ros2::serial::_Monitor_default_instance_._instance,
  &::org::ryderrobots::ros2::serial::_BadRequest_default_instance_._instance,
  &::org::ryderrobots::ros2::serial::_FeatureList_default_instance_._instance,
  &::org::ryderrobots::ros2::serial::_Quaternion_default_instance_._instance,
  &::org::ryderrobots::ros2::serial::_Vector3_default_instance_._instance,
  &::org::ryderrobots::ros2::serial::_MspRawImu_default_instance_._instance,
  &::org::ryderrobots::ros2::serial::_MspIdent_default_instance_._instance,
  &::org::ryderrobots::ros2::serial::_Request_default_instance_._instance,
  &::org::ryderrobots::ros2::serial::_Response_default_instance_._instance,
};

const char descriptor_table_protodef_rr_5fserial_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\017rr_serial.proto\022\033org.ryderrobots.ros2."
  "serial\"\035\n\007Monitor\022\022\n\nis_request\030\001 \001(\010\"C\n"
  "\nBadRequest\0225\n\005etype\030\001 \001(\0162&.org.ryderro"
  "bots.ros2.serial.ErrorType\"\244\003\n\013FeatureLi"
  "st\022\017\n\007has_gps\030\001 \001(\010\022\017\n\007has_joy\030\002 \001(\010\022\026\n\016"
  "has_batt_state\030\003 \001(\010\022\017\n\007has_img\030\004 \001(\010\022\017\n"
  "\007has_imu\030\005 \001(\010\022\022\n\nhas_ranges\030\006 \001(\010\0227\n\ngp"
  "s_status\030\007 \001(\0162#.org.ryderrobots.ros2.se"
  "rial.Status\0227\n\njoy_status\030\010 \001(\0162#.org.ry"
  "derrobots.ros2.serial.Status\022>\n\021batt_sta"
  "te_status\030\t \001(\0162#.org.ryderrobots.ros2.s"
  "erial.Status\0227\n\nimg_status\030\n \001(\0162#.org.r"
  "yderrobots.ros2.serial.Status\022:\n\rranges_"
  "status\030\013 \001(\0162#.org.ryderrobots.ros2.seri"
  "al.Status\"8\n\nQuaternion\022\t\n\001x\030\001 \001(\001\022\t\n\001y\030"
  "\002 \001(\001\022\t\n\001z\030\003 \001(\001\022\t\n\001w\030\004 \001(\001\"*\n\007Vector3\022\t"
  "\n\001x\030\001 \001(\001\022\t\n\001y\030\002 \001(\001\022\t\n\001z\030\003 \001(\001\"\271\002\n\tMspR"
  "awImu\022<\n\013orientation\030\001 \001(\0132\'.org.ryderro"
  "bots.ros2.serial.Quaternion\022\036\n\026orientati"
  "on_covariance\030\002 \003(\001\022>\n\020angular_velocity\030"
  "\003 \001(\0132$.org.ryderrobots.ros2.serial.Vect"
  "or3\022#\n\033angular_velocity_covariance\030\004 \003(\001"
  "\022A\n\023linear_acceleration\030\005 \001(\0132$.org.ryde"
  "rrobots.ros2.serial.Vector3\022&\n\036linear_ac"
  "celeration_covariance\030\006 \003(\001\"J\n\010MspIdent\022"
  ">\n\014feature_list\030\001 \001(\0132(.org.ryderrobots."
  "ros2.serial.FeatureList\"V\n\007Request\022\n\n\002op"
  "\030\001 \001(\005\0227\n\007monitor\030\002 \001(\0132$.org.ryderrobot"
  "s.ros2.serial.MonitorH\000B\006\n\004data\"\331\001\n\010Resp"
  "onse\022\n\n\002op\030\001 \001(\005\022>\n\013bad_request\030\002 \001(\0132\'."
  "org.ryderrobots.ros2.serial.BadRequestH\000"
  "\022=\n\013msp_raw_imu\030\003 \001(\0132&.org.ryderrobots."
  "ros2.serial.MspRawImuH\000\022:\n\tmsp_ident\030\004 \001"
  "(\0132%.org.ryderrobots.ros2.serial.MspIden"
  "tH\000B\006\n\004data*\227\001\n\tErrorType\022\016\n\nET_UNKNOWN\020"
  "\000\022\025\n\021ET_MAX_LEN_EXCEED\020\001\022\032\n\026ET_SERVICE_U"
  "NAVAILABLE\020\002\022\030\n\024ET_UNKNOWN_OPERATION\020\003\022\026"
  "\n\022ET_INVALID_REQUEST\020\004\022\025\n\021ET_SERIAL_FAIL"
  "URE\020\005*@\n\006Status\022\013\n\007UNKNOWN\020\000\022\t\n\005READY\020\001\022"
  "\021\n\rNOT_AVAILABLE\020\002\022\013\n\007FAILURE\020\003b\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_rr_5fserial_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_rr_5fserial_2eproto = {
    false, false, 1599, descriptor_table_protodef_rr_5fserial_2eproto,
    "rr_serial.proto",
    &descriptor_table_rr_5fserial_2eproto_once, nullptr, 0, 9,
    schemas, file_default_instances, TableStruct_rr_5fserial_2eproto::offsets,
    file_level_metadata_rr_5fserial_2eproto, file_level_enum_descriptors_rr_5fserial_2eproto,
    file_level_service_descriptors_rr_5fserial_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_rr_5fserial_2eproto_getter() {
  return &descriptor_table_rr_5fserial_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_rr_5fserial_2eproto(&descriptor_table_rr_5fserial_2eproto);
namespace org {
namespace ryderrobots {
namespace ros2 {
namespace serial {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ErrorType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_rr_5fserial_2eproto);
  return file_level_enum_descriptors_rr_5fserial_2eproto[0];
}
bool ErrorType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Status_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_rr_5fserial_2eproto);
  return file_level_enum_descriptors_rr_5fserial_2eproto[1];
}
bool Status_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class Monitor::_Internal {
 public:
};

Monitor::Monitor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:org.ryderrobots.ros2.serial.Monitor)
}
Monitor::Monitor(const Monitor& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Monitor* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.is_request_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.is_request_ = from._impl_.is_request_;
  // @@protoc_insertion_point(copy_constructor:org.ryderrobots.ros2.serial.Monitor)
}

inline void Monitor::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.is_request_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Monitor::~Monitor() {
  // @@protoc_insertion_point(destructor:org.ryderrobots.ros2.serial.Monitor)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Monitor::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Monitor::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Monitor::Clear() {
// @@protoc_insertion_point(message_clear_start:org.ryderrobots.ros2.serial.Monitor)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.is_request_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Monitor::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool is_request = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.is_request_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Monitor::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:org.ryderrobots.ros2.serial.Monitor)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool is_request = 1;
  if (this->_internal_is_request() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_is_request(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:org.ryderrobots.ros2.serial.Monitor)
  return target;
}

size_t Monitor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:org.ryderrobots.ros2.serial.Monitor)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool is_request = 1;
  if (this->_internal_is_request() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Monitor::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Monitor::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Monitor::GetClassData() const { return &_class_data_; }


void Monitor::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Monitor*>(&to_msg);
  auto& from = static_cast<const Monitor&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:org.ryderrobots.ros2.serial.Monitor)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_is_request() != 0) {
    _this->_internal_set_is_request(from._internal_is_request());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Monitor::CopyFrom(const Monitor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:org.ryderrobots.ros2.serial.Monitor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Monitor::IsInitialized() const {
  return true;
}

void Monitor::InternalSwap(Monitor* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.is_request_, other->_impl_.is_request_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Monitor::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rr_5fserial_2eproto_getter, &descriptor_table_rr_5fserial_2eproto_once,
      file_level_metadata_rr_5fserial_2eproto[0]);
}

// ===================================================================

class BadRequest::_Internal {
 public:
};

BadRequest::BadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:org.ryderrobots.ros2.serial.BadRequest)
}
BadRequest::BadRequest(const BadRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BadRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.etype_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.etype_ = from._impl_.etype_;
  // @@protoc_insertion_point(copy_constructor:org.ryderrobots.ros2.serial.BadRequest)
}

inline void BadRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.etype_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BadRequest::~BadRequest() {
  // @@protoc_insertion_point(destructor:org.ryderrobots.ros2.serial.BadRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BadRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BadRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BadRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:org.ryderrobots.ros2.serial.BadRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.etype_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BadRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .org.ryderrobots.ros2.serial.ErrorType etype = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_etype(static_cast<::org::ryderrobots::ros2::serial::ErrorType>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BadRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:org.ryderrobots.ros2.serial.BadRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .org.ryderrobots.ros2.serial.ErrorType etype = 1;
  if (this->_internal_etype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_etype(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:org.ryderrobots.ros2.serial.BadRequest)
  return target;
}

size_t BadRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:org.ryderrobots.ros2.serial.BadRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .org.ryderrobots.ros2.serial.ErrorType etype = 1;
  if (this->_internal_etype() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_etype());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BadRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BadRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BadRequest::GetClassData() const { return &_class_data_; }


void BadRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BadRequest*>(&to_msg);
  auto& from = static_cast<const BadRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:org.ryderrobots.ros2.serial.BadRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_etype() != 0) {
    _this->_internal_set_etype(from._internal_etype());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BadRequest::CopyFrom(const BadRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:org.ryderrobots.ros2.serial.BadRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BadRequest::IsInitialized() const {
  return true;
}

void BadRequest::InternalSwap(BadRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.etype_, other->_impl_.etype_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BadRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rr_5fserial_2eproto_getter, &descriptor_table_rr_5fserial_2eproto_once,
      file_level_metadata_rr_5fserial_2eproto[1]);
}

// ===================================================================

class FeatureList::_Internal {
 public:
};

FeatureList::FeatureList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:org.ryderrobots.ros2.serial.FeatureList)
}
FeatureList::FeatureList(const FeatureList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FeatureList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.has_gps_){}
    , decltype(_impl_.has_joy_){}
    , decltype(_impl_.has_batt_state_){}
    , decltype(_impl_.has_img_){}
    , decltype(_impl_.has_imu_){}
    , decltype(_impl_.has_ranges_){}
    , decltype(_impl_.gps_status_){}
    , decltype(_impl_.joy_status_){}
    , decltype(_impl_.batt_state_status_){}
    , decltype(_impl_.img_status_){}
    , decltype(_impl_.ranges_status_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.has_gps_, &from._impl_.has_gps_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ranges_status_) -
    reinterpret_cast<char*>(&_impl_.has_gps_)) + sizeof(_impl_.ranges_status_));
  // @@protoc_insertion_point(copy_constructor:org.ryderrobots.ros2.serial.FeatureList)
}

inline void FeatureList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.has_gps_){false}
    , decltype(_impl_.has_joy_){false}
    , decltype(_impl_.has_batt_state_){false}
    , decltype(_impl_.has_img_){false}
    , decltype(_impl_.has_imu_){false}
    , decltype(_impl_.has_ranges_){false}
    , decltype(_impl_.gps_status_){0}
    , decltype(_impl_.joy_status_){0}
    , decltype(_impl_.batt_state_status_){0}
    , decltype(_impl_.img_status_){0}
    , decltype(_impl_.ranges_status_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FeatureList::~FeatureList() {
  // @@protoc_insertion_point(destructor:org.ryderrobots.ros2.serial.FeatureList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FeatureList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FeatureList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FeatureList::Clear() {
// @@protoc_insertion_point(message_clear_start:org.ryderrobots.ros2.serial.FeatureList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.has_gps_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.ranges_status_) -
      reinterpret_cast<char*>(&_impl_.has_gps_)) + sizeof(_impl_.ranges_status_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FeatureList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool has_gps = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.has_gps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool has_joy = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.has_joy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool has_batt_state = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.has_batt_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool has_img = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.has_img_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool has_imu = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.has_imu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool has_ranges = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.has_ranges_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .org.ryderrobots.ros2.serial.Status gps_status = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_gps_status(static_cast<::org::ryderrobots::ros2::serial::Status>(val));
        } else
          goto handle_unusual;
        continue;
      // .org.ryderrobots.ros2.serial.Status joy_status = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_joy_status(static_cast<::org::ryderrobots::ros2::serial::Status>(val));
        } else
          goto handle_unusual;
        continue;
      // .org.ryderrobots.ros2.serial.Status batt_state_status = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_batt_state_status(static_cast<::org::ryderrobots::ros2::serial::Status>(val));
        } else
          goto handle_unusual;
        continue;
      // .org.ryderrobots.ros2.serial.Status img_status = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_img_status(static_cast<::org::ryderrobots::ros2::serial::Status>(val));
        } else
          goto handle_unusual;
        continue;
      // .org.ryderrobots.ros2.serial.Status ranges_status = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_ranges_status(static_cast<::org::ryderrobots::ros2::serial::Status>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FeatureList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:org.ryderrobots.ros2.serial.FeatureList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool has_gps = 1;
  if (this->_internal_has_gps() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_has_gps(), target);
  }

  // bool has_joy = 2;
  if (this->_internal_has_joy() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_has_joy(), target);
  }

  // bool has_batt_state = 3;
  if (this->_internal_has_batt_state() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_has_batt_state(), target);
  }

  // bool has_img = 4;
  if (this->_internal_has_img() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_has_img(), target);
  }

  // bool has_imu = 5;
  if (this->_internal_has_imu() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_has_imu(), target);
  }

  // bool has_ranges = 6;
  if (this->_internal_has_ranges() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_has_ranges(), target);
  }

  // .org.ryderrobots.ros2.serial.Status gps_status = 7;
  if (this->_internal_gps_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_gps_status(), target);
  }

  // .org.ryderrobots.ros2.serial.Status joy_status = 8;
  if (this->_internal_joy_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_joy_status(), target);
  }

  // .org.ryderrobots.ros2.serial.Status batt_state_status = 9;
  if (this->_internal_batt_state_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_batt_state_status(), target);
  }

  // .org.ryderrobots.ros2.serial.Status img_status = 10;
  if (this->_internal_img_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      10, this->_internal_img_status(), target);
  }

  // .org.ryderrobots.ros2.serial.Status ranges_status = 11;
  if (this->_internal_ranges_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      11, this->_internal_ranges_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:org.ryderrobots.ros2.serial.FeatureList)
  return target;
}

size_t FeatureList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:org.ryderrobots.ros2.serial.FeatureList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool has_gps = 1;
  if (this->_internal_has_gps() != 0) {
    total_size += 1 + 1;
  }

  // bool has_joy = 2;
  if (this->_internal_has_joy() != 0) {
    total_size += 1 + 1;
  }

  // bool has_batt_state = 3;
  if (this->_internal_has_batt_state() != 0) {
    total_size += 1 + 1;
  }

  // bool has_img = 4;
  if (this->_internal_has_img() != 0) {
    total_size += 1 + 1;
  }

  // bool has_imu = 5;
  if (this->_internal_has_imu() != 0) {
    total_size += 1 + 1;
  }

  // bool has_ranges = 6;
  if (this->_internal_has_ranges() != 0) {
    total_size += 1 + 1;
  }

  // .org.ryderrobots.ros2.serial.Status gps_status = 7;
  if (this->_internal_gps_status() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_gps_status());
  }

  // .org.ryderrobots.ros2.serial.Status joy_status = 8;
  if (this->_internal_joy_status() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_joy_status());
  }

  // .org.ryderrobots.ros2.serial.Status batt_state_status = 9;
  if (this->_internal_batt_state_status() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_batt_state_status());
  }

  // .org.ryderrobots.ros2.serial.Status img_status = 10;
  if (this->_internal_img_status() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_img_status());
  }

  // .org.ryderrobots.ros2.serial.Status ranges_status = 11;
  if (this->_internal_ranges_status() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_ranges_status());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FeatureList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FeatureList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FeatureList::GetClassData() const { return &_class_data_; }


void FeatureList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FeatureList*>(&to_msg);
  auto& from = static_cast<const FeatureList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:org.ryderrobots.ros2.serial.FeatureList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_gps() != 0) {
    _this->_internal_set_has_gps(from._internal_has_gps());
  }
  if (from._internal_has_joy() != 0) {
    _this->_internal_set_has_joy(from._internal_has_joy());
  }
  if (from._internal_has_batt_state() != 0) {
    _this->_internal_set_has_batt_state(from._internal_has_batt_state());
  }
  if (from._internal_has_img() != 0) {
    _this->_internal_set_has_img(from._internal_has_img());
  }
  if (from._internal_has_imu() != 0) {
    _this->_internal_set_has_imu(from._internal_has_imu());
  }
  if (from._internal_has_ranges() != 0) {
    _this->_internal_set_has_ranges(from._internal_has_ranges());
  }
  if (from._internal_gps_status() != 0) {
    _this->_internal_set_gps_status(from._internal_gps_status());
  }
  if (from._internal_joy_status() != 0) {
    _this->_internal_set_joy_status(from._internal_joy_status());
  }
  if (from._internal_batt_state_status() != 0) {
    _this->_internal_set_batt_state_status(from._internal_batt_state_status());
  }
  if (from._internal_img_status() != 0) {
    _this->_internal_set_img_status(from._internal_img_status());
  }
  if (from._internal_ranges_status() != 0) {
    _this->_internal_set_ranges_status(from._internal_ranges_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FeatureList::CopyFrom(const FeatureList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:org.ryderrobots.ros2.serial.FeatureList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FeatureList::IsInitialized() const {
  return true;
}

void FeatureList::InternalSwap(FeatureList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FeatureList, _impl_.ranges_status_)
      + sizeof(FeatureList::_impl_.ranges_status_)
      - PROTOBUF_FIELD_OFFSET(FeatureList, _impl_.has_gps_)>(
          reinterpret_cast<char*>(&_impl_.has_gps_),
          reinterpret_cast<char*>(&other->_impl_.has_gps_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FeatureList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rr_5fserial_2eproto_getter, &descriptor_table_rr_5fserial_2eproto_once,
      file_level_metadata_rr_5fserial_2eproto[2]);
}

// ===================================================================

class Quaternion::_Internal {
 public:
};

Quaternion::Quaternion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:org.ryderrobots.ros2.serial.Quaternion)
}
Quaternion::Quaternion(const Quaternion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Quaternion* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , decltype(_impl_.w_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.w_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.w_));
  // @@protoc_insertion_point(copy_constructor:org.ryderrobots.ros2.serial.Quaternion)
}

inline void Quaternion::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
    , decltype(_impl_.w_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Quaternion::~Quaternion() {
  // @@protoc_insertion_point(destructor:org.ryderrobots.ros2.serial.Quaternion)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Quaternion::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Quaternion::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Quaternion::Clear() {
// @@protoc_insertion_point(message_clear_start:org.ryderrobots.ros2.serial.Quaternion)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.w_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.w_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Quaternion::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double w = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.w_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Quaternion::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:org.ryderrobots.ros2.serial.Quaternion)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double x = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_x(), target);
  }

  // double y = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_y(), target);
  }

  // double z = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_z(), target);
  }

  // double w = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_w = this->_internal_w();
  uint64_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_w(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:org.ryderrobots.ros2.serial.Quaternion)
  return target;
}

size_t Quaternion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:org.ryderrobots.ros2.serial.Quaternion)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double x = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 8;
  }

  // double y = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 8;
  }

  // double z = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 1 + 8;
  }

  // double w = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_w = this->_internal_w();
  uint64_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Quaternion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Quaternion::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Quaternion::GetClassData() const { return &_class_data_; }


void Quaternion::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Quaternion*>(&to_msg);
  auto& from = static_cast<const Quaternion&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:org.ryderrobots.ros2.serial.Quaternion)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = from._internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = from._internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = from._internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_w = from._internal_w();
  uint64_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    _this->_internal_set_w(from._internal_w());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Quaternion::CopyFrom(const Quaternion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:org.ryderrobots.ros2.serial.Quaternion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Quaternion::IsInitialized() const {
  return true;
}

void Quaternion::InternalSwap(Quaternion* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Quaternion, _impl_.w_)
      + sizeof(Quaternion::_impl_.w_)
      - PROTOBUF_FIELD_OFFSET(Quaternion, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Quaternion::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rr_5fserial_2eproto_getter, &descriptor_table_rr_5fserial_2eproto_once,
      file_level_metadata_rr_5fserial_2eproto[3]);
}

// ===================================================================

class Vector3::_Internal {
 public:
};

Vector3::Vector3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:org.ryderrobots.ros2.serial.Vector3)
}
Vector3::Vector3(const Vector3& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Vector3* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.z_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  // @@protoc_insertion_point(copy_constructor:org.ryderrobots.ros2.serial.Vector3)
}

inline void Vector3::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Vector3::~Vector3() {
  // @@protoc_insertion_point(destructor:org.ryderrobots.ros2.serial.Vector3)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Vector3::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Vector3::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Vector3::Clear() {
// @@protoc_insertion_point(message_clear_start:org.ryderrobots.ros2.serial.Vector3)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.z_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Vector3::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Vector3::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:org.ryderrobots.ros2.serial.Vector3)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double x = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_x(), target);
  }

  // double y = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_y(), target);
  }

  // double z = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:org.ryderrobots.ros2.serial.Vector3)
  return target;
}

size_t Vector3::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:org.ryderrobots.ros2.serial.Vector3)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double x = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 8;
  }

  // double y = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 8;
  }

  // double z = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Vector3::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Vector3::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Vector3::GetClassData() const { return &_class_data_; }


void Vector3::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Vector3*>(&to_msg);
  auto& from = static_cast<const Vector3&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:org.ryderrobots.ros2.serial.Vector3)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = from._internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = from._internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = from._internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Vector3::CopyFrom(const Vector3& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:org.ryderrobots.ros2.serial.Vector3)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vector3::IsInitialized() const {
  return true;
}

void Vector3::InternalSwap(Vector3* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Vector3, _impl_.z_)
      + sizeof(Vector3::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(Vector3, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Vector3::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rr_5fserial_2eproto_getter, &descriptor_table_rr_5fserial_2eproto_once,
      file_level_metadata_rr_5fserial_2eproto[4]);
}

// ===================================================================

class MspRawImu::_Internal {
 public:
  static const ::org::ryderrobots::ros2::serial::Quaternion& orientation(const MspRawImu* msg);
  static const ::org::ryderrobots::ros2::serial::Vector3& angular_velocity(const MspRawImu* msg);
  static const ::org::ryderrobots::ros2::serial::Vector3& linear_acceleration(const MspRawImu* msg);
};

const ::org::ryderrobots::ros2::serial::Quaternion&
MspRawImu::_Internal::orientation(const MspRawImu* msg) {
  return *msg->_impl_.orientation_;
}
const ::org::ryderrobots::ros2::serial::Vector3&
MspRawImu::_Internal::angular_velocity(const MspRawImu* msg) {
  return *msg->_impl_.angular_velocity_;
}
const ::org::ryderrobots::ros2::serial::Vector3&
MspRawImu::_Internal::linear_acceleration(const MspRawImu* msg) {
  return *msg->_impl_.linear_acceleration_;
}
MspRawImu::MspRawImu(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:org.ryderrobots.ros2.serial.MspRawImu)
}
MspRawImu::MspRawImu(const MspRawImu& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MspRawImu* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.orientation_covariance_){from._impl_.orientation_covariance_}
    , decltype(_impl_.angular_velocity_covariance_){from._impl_.angular_velocity_covariance_}
    , decltype(_impl_.linear_acceleration_covariance_){from._impl_.linear_acceleration_covariance_}
    , decltype(_impl_.orientation_){nullptr}
    , decltype(_impl_.angular_velocity_){nullptr}
    , decltype(_impl_.linear_acceleration_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_orientation()) {
    _this->_impl_.orientation_ = new ::org::ryderrobots::ros2::serial::Quaternion(*from._impl_.orientation_);
  }
  if (from._internal_has_angular_velocity()) {
    _this->_impl_.angular_velocity_ = new ::org::ryderrobots::ros2::serial::Vector3(*from._impl_.angular_velocity_);
  }
  if (from._internal_has_linear_acceleration()) {
    _this->_impl_.linear_acceleration_ = new ::org::ryderrobots::ros2::serial::Vector3(*from._impl_.linear_acceleration_);
  }
  // @@protoc_insertion_point(copy_constructor:org.ryderrobots.ros2.serial.MspRawImu)
}

inline void MspRawImu::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.orientation_covariance_){arena}
    , decltype(_impl_.angular_velocity_covariance_){arena}
    , decltype(_impl_.linear_acceleration_covariance_){arena}
    , decltype(_impl_.orientation_){nullptr}
    , decltype(_impl_.angular_velocity_){nullptr}
    , decltype(_impl_.linear_acceleration_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MspRawImu::~MspRawImu() {
  // @@protoc_insertion_point(destructor:org.ryderrobots.ros2.serial.MspRawImu)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MspRawImu::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.orientation_covariance_.~RepeatedField();
  _impl_.angular_velocity_covariance_.~RepeatedField();
  _impl_.linear_acceleration_covariance_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.orientation_;
  if (this != internal_default_instance()) delete _impl_.angular_velocity_;
  if (this != internal_default_instance()) delete _impl_.linear_acceleration_;
}

void MspRawImu::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MspRawImu::Clear() {
// @@protoc_insertion_point(message_clear_start:org.ryderrobots.ros2.serial.MspRawImu)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.orientation_covariance_.Clear();
  _impl_.angular_velocity_covariance_.Clear();
  _impl_.linear_acceleration_covariance_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.orientation_ != nullptr) {
    delete _impl_.orientation_;
  }
  _impl_.orientation_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.angular_velocity_ != nullptr) {
    delete _impl_.angular_velocity_;
  }
  _impl_.angular_velocity_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.linear_acceleration_ != nullptr) {
    delete _impl_.linear_acceleration_;
  }
  _impl_.linear_acceleration_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MspRawImu::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .org.ryderrobots.ros2.serial.Quaternion orientation = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_orientation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated double orientation_covariance = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_orientation_covariance(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 17) {
          _internal_add_orientation_covariance(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // .org.ryderrobots.ros2.serial.Vector3 angular_velocity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_angular_velocity(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated double angular_velocity_covariance = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_angular_velocity_covariance(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 33) {
          _internal_add_angular_velocity_covariance(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // .org.ryderrobots.ros2.serial.Vector3 linear_acceleration = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_linear_acceleration(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated double linear_acceleration_covariance = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_linear_acceleration_covariance(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 49) {
          _internal_add_linear_acceleration_covariance(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MspRawImu::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:org.ryderrobots.ros2.serial.MspRawImu)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .org.ryderrobots.ros2.serial.Quaternion orientation = 1;
  if (this->_internal_has_orientation()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::orientation(this),
        _Internal::orientation(this).GetCachedSize(), target, stream);
  }

  // repeated double orientation_covariance = 2;
  if (this->_internal_orientation_covariance_size() > 0) {
    target = stream->WriteFixedPacked(2, _internal_orientation_covariance(), target);
  }

  // .org.ryderrobots.ros2.serial.Vector3 angular_velocity = 3;
  if (this->_internal_has_angular_velocity()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::angular_velocity(this),
        _Internal::angular_velocity(this).GetCachedSize(), target, stream);
  }

  // repeated double angular_velocity_covariance = 4;
  if (this->_internal_angular_velocity_covariance_size() > 0) {
    target = stream->WriteFixedPacked(4, _internal_angular_velocity_covariance(), target);
  }

  // .org.ryderrobots.ros2.serial.Vector3 linear_acceleration = 5;
  if (this->_internal_has_linear_acceleration()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::linear_acceleration(this),
        _Internal::linear_acceleration(this).GetCachedSize(), target, stream);
  }

  // repeated double linear_acceleration_covariance = 6;
  if (this->_internal_linear_acceleration_covariance_size() > 0) {
    target = stream->WriteFixedPacked(6, _internal_linear_acceleration_covariance(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:org.ryderrobots.ros2.serial.MspRawImu)
  return target;
}

size_t MspRawImu::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:org.ryderrobots.ros2.serial.MspRawImu)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double orientation_covariance = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_orientation_covariance_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated double angular_velocity_covariance = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_angular_velocity_covariance_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated double linear_acceleration_covariance = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_linear_acceleration_covariance_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // .org.ryderrobots.ros2.serial.Quaternion orientation = 1;
  if (this->_internal_has_orientation()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.orientation_);
  }

  // .org.ryderrobots.ros2.serial.Vector3 angular_velocity = 3;
  if (this->_internal_has_angular_velocity()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.angular_velocity_);
  }

  // .org.ryderrobots.ros2.serial.Vector3 linear_acceleration = 5;
  if (this->_internal_has_linear_acceleration()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.linear_acceleration_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MspRawImu::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MspRawImu::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MspRawImu::GetClassData() const { return &_class_data_; }


void MspRawImu::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MspRawImu*>(&to_msg);
  auto& from = static_cast<const MspRawImu&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:org.ryderrobots.ros2.serial.MspRawImu)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.orientation_covariance_.MergeFrom(from._impl_.orientation_covariance_);
  _this->_impl_.angular_velocity_covariance_.MergeFrom(from._impl_.angular_velocity_covariance_);
  _this->_impl_.linear_acceleration_covariance_.MergeFrom(from._impl_.linear_acceleration_covariance_);
  if (from._internal_has_orientation()) {
    _this->_internal_mutable_orientation()->::org::ryderrobots::ros2::serial::Quaternion::MergeFrom(
        from._internal_orientation());
  }
  if (from._internal_has_angular_velocity()) {
    _this->_internal_mutable_angular_velocity()->::org::ryderrobots::ros2::serial::Vector3::MergeFrom(
        from._internal_angular_velocity());
  }
  if (from._internal_has_linear_acceleration()) {
    _this->_internal_mutable_linear_acceleration()->::org::ryderrobots::ros2::serial::Vector3::MergeFrom(
        from._internal_linear_acceleration());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MspRawImu::CopyFrom(const MspRawImu& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:org.ryderrobots.ros2.serial.MspRawImu)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MspRawImu::IsInitialized() const {
  return true;
}

void MspRawImu::InternalSwap(MspRawImu* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.orientation_covariance_.InternalSwap(&other->_impl_.orientation_covariance_);
  _impl_.angular_velocity_covariance_.InternalSwap(&other->_impl_.angular_velocity_covariance_);
  _impl_.linear_acceleration_covariance_.InternalSwap(&other->_impl_.linear_acceleration_covariance_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MspRawImu, _impl_.linear_acceleration_)
      + sizeof(MspRawImu::_impl_.linear_acceleration_)
      - PROTOBUF_FIELD_OFFSET(MspRawImu, _impl_.orientation_)>(
          reinterpret_cast<char*>(&_impl_.orientation_),
          reinterpret_cast<char*>(&other->_impl_.orientation_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MspRawImu::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rr_5fserial_2eproto_getter, &descriptor_table_rr_5fserial_2eproto_once,
      file_level_metadata_rr_5fserial_2eproto[5]);
}

// ===================================================================

class MspIdent::_Internal {
 public:
  static const ::org::ryderrobots::ros2::serial::FeatureList& feature_list(const MspIdent* msg);
};

const ::org::ryderrobots::ros2::serial::FeatureList&
MspIdent::_Internal::feature_list(const MspIdent* msg) {
  return *msg->_impl_.feature_list_;
}
MspIdent::MspIdent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:org.ryderrobots.ros2.serial.MspIdent)
}
MspIdent::MspIdent(const MspIdent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MspIdent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.feature_list_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_feature_list()) {
    _this->_impl_.feature_list_ = new ::org::ryderrobots::ros2::serial::FeatureList(*from._impl_.feature_list_);
  }
  // @@protoc_insertion_point(copy_constructor:org.ryderrobots.ros2.serial.MspIdent)
}

inline void MspIdent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.feature_list_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MspIdent::~MspIdent() {
  // @@protoc_insertion_point(destructor:org.ryderrobots.ros2.serial.MspIdent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MspIdent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.feature_list_;
}

void MspIdent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MspIdent::Clear() {
// @@protoc_insertion_point(message_clear_start:org.ryderrobots.ros2.serial.MspIdent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.feature_list_ != nullptr) {
    delete _impl_.feature_list_;
  }
  _impl_.feature_list_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MspIdent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .org.ryderrobots.ros2.serial.FeatureList feature_list = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_feature_list(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MspIdent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:org.ryderrobots.ros2.serial.MspIdent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .org.ryderrobots.ros2.serial.FeatureList feature_list = 1;
  if (this->_internal_has_feature_list()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::feature_list(this),
        _Internal::feature_list(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:org.ryderrobots.ros2.serial.MspIdent)
  return target;
}

size_t MspIdent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:org.ryderrobots.ros2.serial.MspIdent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .org.ryderrobots.ros2.serial.FeatureList feature_list = 1;
  if (this->_internal_has_feature_list()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.feature_list_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MspIdent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MspIdent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MspIdent::GetClassData() const { return &_class_data_; }


void MspIdent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MspIdent*>(&to_msg);
  auto& from = static_cast<const MspIdent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:org.ryderrobots.ros2.serial.MspIdent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_feature_list()) {
    _this->_internal_mutable_feature_list()->::org::ryderrobots::ros2::serial::FeatureList::MergeFrom(
        from._internal_feature_list());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MspIdent::CopyFrom(const MspIdent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:org.ryderrobots.ros2.serial.MspIdent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MspIdent::IsInitialized() const {
  return true;
}

void MspIdent::InternalSwap(MspIdent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.feature_list_, other->_impl_.feature_list_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MspIdent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rr_5fserial_2eproto_getter, &descriptor_table_rr_5fserial_2eproto_once,
      file_level_metadata_rr_5fserial_2eproto[6]);
}

// ===================================================================

class Request::_Internal {
 public:
  static const ::org::ryderrobots::ros2::serial::Monitor& monitor(const Request* msg);
};

const ::org::ryderrobots::ros2::serial::Monitor&
Request::_Internal::monitor(const Request* msg) {
  return *msg->_impl_.data_.monitor_;
}
void Request::set_allocated_monitor(::org::ryderrobots::ros2::serial::Monitor* monitor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (monitor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(monitor);
    if (message_arena != submessage_arena) {
      monitor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, monitor, submessage_arena);
    }
    set_has_monitor();
    _impl_.data_.monitor_ = monitor;
  }
  // @@protoc_insertion_point(field_set_allocated:org.ryderrobots.ros2.serial.Request.monitor)
}
Request::Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:org.ryderrobots.ros2.serial.Request)
}
Request::Request(const Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Request* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.op_){}
    , decltype(_impl_.data_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.op_ = from._impl_.op_;
  clear_has_data();
  switch (from.data_case()) {
    case kMonitor: {
      _this->_internal_mutable_monitor()->::org::ryderrobots::ros2::serial::Monitor::MergeFrom(
          from._internal_monitor());
      break;
    }
    case DATA_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:org.ryderrobots.ros2.serial.Request)
}

inline void Request::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.op_){0}
    , decltype(_impl_.data_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_data();
}

Request::~Request() {
  // @@protoc_insertion_point(destructor:org.ryderrobots.ros2.serial.Request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_data()) {
    clear_data();
  }
}

void Request::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Request::clear_data() {
// @@protoc_insertion_point(one_of_clear_start:org.ryderrobots.ros2.serial.Request)
  switch (data_case()) {
    case kMonitor: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.data_.monitor_;
      }
      break;
    }
    case DATA_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}


void Request::Clear() {
// @@protoc_insertion_point(message_clear_start:org.ryderrobots.ros2.serial.Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.op_ = 0;
  clear_data();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 op = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.op_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .org.ryderrobots.ros2.serial.Monitor monitor = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_monitor(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:org.ryderrobots.ros2.serial.Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 op = 1;
  if (this->_internal_op() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_op(), target);
  }

  // .org.ryderrobots.ros2.serial.Monitor monitor = 2;
  if (_internal_has_monitor()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::monitor(this),
        _Internal::monitor(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:org.ryderrobots.ros2.serial.Request)
  return target;
}

size_t Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:org.ryderrobots.ros2.serial.Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 op = 1;
  if (this->_internal_op() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_op());
  }

  switch (data_case()) {
    // .org.ryderrobots.ros2.serial.Monitor monitor = 2;
    case kMonitor: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_.monitor_);
      break;
    }
    case DATA_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Request::GetClassData() const { return &_class_data_; }


void Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Request*>(&to_msg);
  auto& from = static_cast<const Request&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:org.ryderrobots.ros2.serial.Request)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_op() != 0) {
    _this->_internal_set_op(from._internal_op());
  }
  switch (from.data_case()) {
    case kMonitor: {
      _this->_internal_mutable_monitor()->::org::ryderrobots::ros2::serial::Monitor::MergeFrom(
          from._internal_monitor());
      break;
    }
    case DATA_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Request::CopyFrom(const Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:org.ryderrobots.ros2.serial.Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Request::IsInitialized() const {
  return true;
}

void Request::InternalSwap(Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.op_, other->_impl_.op_);
  swap(_impl_.data_, other->_impl_.data_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Request::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rr_5fserial_2eproto_getter, &descriptor_table_rr_5fserial_2eproto_once,
      file_level_metadata_rr_5fserial_2eproto[7]);
}

// ===================================================================

class Response::_Internal {
 public:
  static const ::org::ryderrobots::ros2::serial::BadRequest& bad_request(const Response* msg);
  static const ::org::ryderrobots::ros2::serial::MspRawImu& msp_raw_imu(const Response* msg);
  static const ::org::ryderrobots::ros2::serial::MspIdent& msp_ident(const Response* msg);
};

const ::org::ryderrobots::ros2::serial::BadRequest&
Response::_Internal::bad_request(const Response* msg) {
  return *msg->_impl_.data_.bad_request_;
}
const ::org::ryderrobots::ros2::serial::MspRawImu&
Response::_Internal::msp_raw_imu(const Response* msg) {
  return *msg->_impl_.data_.msp_raw_imu_;
}
const ::org::ryderrobots::ros2::serial::MspIdent&
Response::_Internal::msp_ident(const Response* msg) {
  return *msg->_impl_.data_.msp_ident_;
}
void Response::set_allocated_bad_request(::org::ryderrobots::ros2::serial::BadRequest* bad_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (bad_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bad_request);
    if (message_arena != submessage_arena) {
      bad_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bad_request, submessage_arena);
    }
    set_has_bad_request();
    _impl_.data_.bad_request_ = bad_request;
  }
  // @@protoc_insertion_point(field_set_allocated:org.ryderrobots.ros2.serial.Response.bad_request)
}
void Response::set_allocated_msp_raw_imu(::org::ryderrobots::ros2::serial::MspRawImu* msp_raw_imu) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (msp_raw_imu) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(msp_raw_imu);
    if (message_arena != submessage_arena) {
      msp_raw_imu = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, msp_raw_imu, submessage_arena);
    }
    set_has_msp_raw_imu();
    _impl_.data_.msp_raw_imu_ = msp_raw_imu;
  }
  // @@protoc_insertion_point(field_set_allocated:org.ryderrobots.ros2.serial.Response.msp_raw_imu)
}
void Response::set_allocated_msp_ident(::org::ryderrobots::ros2::serial::MspIdent* msp_ident) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (msp_ident) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(msp_ident);
    if (message_arena != submessage_arena) {
      msp_ident = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, msp_ident, submessage_arena);
    }
    set_has_msp_ident();
    _impl_.data_.msp_ident_ = msp_ident;
  }
  // @@protoc_insertion_point(field_set_allocated:org.ryderrobots.ros2.serial.Response.msp_ident)
}
Response::Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:org.ryderrobots.ros2.serial.Response)
}
Response::Response(const Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.op_){}
    , decltype(_impl_.data_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.op_ = from._impl_.op_;
  clear_has_data();
  switch (from.data_case()) {
    case kBadRequest: {
      _this->_internal_mutable_bad_request()->::org::ryderrobots::ros2::serial::BadRequest::MergeFrom(
          from._internal_bad_request());
      break;
    }
    case kMspRawImu: {
      _this->_internal_mutable_msp_raw_imu()->::org::ryderrobots::ros2::serial::MspRawImu::MergeFrom(
          from._internal_msp_raw_imu());
      break;
    }
    case kMspIdent: {
      _this->_internal_mutable_msp_ident()->::org::ryderrobots::ros2::serial::MspIdent::MergeFrom(
          from._internal_msp_ident());
      break;
    }
    case DATA_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:org.ryderrobots.ros2.serial.Response)
}

inline void Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.op_){0}
    , decltype(_impl_.data_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_data();
}

Response::~Response() {
  // @@protoc_insertion_point(destructor:org.ryderrobots.ros2.serial.Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_data()) {
    clear_data();
  }
}

void Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Response::clear_data() {
// @@protoc_insertion_point(one_of_clear_start:org.ryderrobots.ros2.serial.Response)
  switch (data_case()) {
    case kBadRequest: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.data_.bad_request_;
      }
      break;
    }
    case kMspRawImu: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.data_.msp_raw_imu_;
      }
      break;
    }
    case kMspIdent: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.data_.msp_ident_;
      }
      break;
    }
    case DATA_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}


void Response::Clear() {
// @@protoc_insertion_point(message_clear_start:org.ryderrobots.ros2.serial.Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.op_ = 0;
  clear_data();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 op = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.op_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .org.ryderrobots.ros2.serial.BadRequest bad_request = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_bad_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .org.ryderrobots.ros2.serial.MspRawImu msp_raw_imu = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_msp_raw_imu(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .org.ryderrobots.ros2.serial.MspIdent msp_ident = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_msp_ident(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:org.ryderrobots.ros2.serial.Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 op = 1;
  if (this->_internal_op() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_op(), target);
  }

  // .org.ryderrobots.ros2.serial.BadRequest bad_request = 2;
  if (_internal_has_bad_request()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::bad_request(this),
        _Internal::bad_request(this).GetCachedSize(), target, stream);
  }

  // .org.ryderrobots.ros2.serial.MspRawImu msp_raw_imu = 3;
  if (_internal_has_msp_raw_imu()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::msp_raw_imu(this),
        _Internal::msp_raw_imu(this).GetCachedSize(), target, stream);
  }

  // .org.ryderrobots.ros2.serial.MspIdent msp_ident = 4;
  if (_internal_has_msp_ident()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::msp_ident(this),
        _Internal::msp_ident(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:org.ryderrobots.ros2.serial.Response)
  return target;
}

size_t Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:org.ryderrobots.ros2.serial.Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 op = 1;
  if (this->_internal_op() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_op());
  }

  switch (data_case()) {
    // .org.ryderrobots.ros2.serial.BadRequest bad_request = 2;
    case kBadRequest: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_.bad_request_);
      break;
    }
    // .org.ryderrobots.ros2.serial.MspRawImu msp_raw_imu = 3;
    case kMspRawImu: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_.msp_raw_imu_);
      break;
    }
    // .org.ryderrobots.ros2.serial.MspIdent msp_ident = 4;
    case kMspIdent: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_.msp_ident_);
      break;
    }
    case DATA_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Response::GetClassData() const { return &_class_data_; }


void Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Response*>(&to_msg);
  auto& from = static_cast<const Response&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:org.ryderrobots.ros2.serial.Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_op() != 0) {
    _this->_internal_set_op(from._internal_op());
  }
  switch (from.data_case()) {
    case kBadRequest: {
      _this->_internal_mutable_bad_request()->::org::ryderrobots::ros2::serial::BadRequest::MergeFrom(
          from._internal_bad_request());
      break;
    }
    case kMspRawImu: {
      _this->_internal_mutable_msp_raw_imu()->::org::ryderrobots::ros2::serial::MspRawImu::MergeFrom(
          from._internal_msp_raw_imu());
      break;
    }
    case kMspIdent: {
      _this->_internal_mutable_msp_ident()->::org::ryderrobots::ros2::serial::MspIdent::MergeFrom(
          from._internal_msp_ident());
      break;
    }
    case DATA_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Response::CopyFrom(const Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:org.ryderrobots.ros2.serial.Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Response::IsInitialized() const {
  return true;
}

void Response::InternalSwap(Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.op_, other->_impl_.op_);
  swap(_impl_.data_, other->_impl_.data_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Response::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rr_5fserial_2eproto_getter, &descriptor_table_rr_5fserial_2eproto_once,
      file_level_metadata_rr_5fserial_2eproto[8]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace serial
}  // namespace ros2
}  // namespace ryderrobots
}  // namespace org
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::org::ryderrobots::ros2::serial::Monitor*
Arena::CreateMaybeMessage< ::org::ryderrobots::ros2::serial::Monitor >(Arena* arena) {
  return Arena::CreateMessageInternal< ::org::ryderrobots::ros2::serial::Monitor >(arena);
}
template<> PROTOBUF_NOINLINE ::org::ryderrobots::ros2::serial::BadRequest*
Arena::CreateMaybeMessage< ::org::ryderrobots::ros2::serial::BadRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::org::ryderrobots::ros2::serial::BadRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::org::ryderrobots::ros2::serial::FeatureList*
Arena::CreateMaybeMessage< ::org::ryderrobots::ros2::serial::FeatureList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::org::ryderrobots::ros2::serial::FeatureList >(arena);
}
template<> PROTOBUF_NOINLINE ::org::ryderrobots::ros2::serial::Quaternion*
Arena::CreateMaybeMessage< ::org::ryderrobots::ros2::serial::Quaternion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::org::ryderrobots::ros2::serial::Quaternion >(arena);
}
template<> PROTOBUF_NOINLINE ::org::ryderrobots::ros2::serial::Vector3*
Arena::CreateMaybeMessage< ::org::ryderrobots::ros2::serial::Vector3 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::org::ryderrobots::ros2::serial::Vector3 >(arena);
}
template<> PROTOBUF_NOINLINE ::org::ryderrobots::ros2::serial::MspRawImu*
Arena::CreateMaybeMessage< ::org::ryderrobots::ros2::serial::MspRawImu >(Arena* arena) {
  return Arena::CreateMessageInternal< ::org::ryderrobots::ros2::serial::MspRawImu >(arena);
}
template<> PROTOBUF_NOINLINE ::org::ryderrobots::ros2::serial::MspIdent*
Arena::CreateMaybeMessage< ::org::ryderrobots::ros2::serial::MspIdent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::org::ryderrobots::ros2::serial::MspIdent >(arena);
}
template<> PROTOBUF_NOINLINE ::org::ryderrobots::ros2::serial::Request*
Arena::CreateMaybeMessage< ::org::ryderrobots::ros2::serial::Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::org::ryderrobots::ros2::serial::Request >(arena);
}
template<> PROTOBUF_NOINLINE ::org::ryderrobots::ros2::serial::Response*
Arena::CreateMaybeMessage< ::org::ryderrobots::ros2::serial::Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::org::ryderrobots::ros2::serial::Response >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
